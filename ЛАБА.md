### Задание
FastCGI сервер на Java, определяющий, попала ли точка в заданную область. HTML-страница формирует данные HTTP-запросом и отправляет их серверу. На HTML-странице есть график, который принимает данные R и координаты точки в пределах графика.

Структура:
	HTML-страница принимает данные: R и (x,y). Сохраняет предыдущие значения.
	Формирует HTTP-запрос, отправляет на сервер (JavaScript)
	FactCGI выполняет валидацию данных
	Возвращает HTML-страницу с таблицей (полученные параметры, рез. вычислений, текущее время, время выполнения запроса.)

Комментарии по выполнению ЛР:
    Требуется поднять Apache httpd веб-сервер от лица своего пользователя на гелиосе (шаблон файла конфигурации доступен для скачивания наверху страницы)
    Веб-сервер должен заниматься обслуживанием статического контента (html, css, js) и перенаправлять запросы за динамическим контентом к FastCGI серверу
    FastCGI сервер требуется реализовать на языке Java (полезная библиотека в помощь в виде jar архива доступна для скачивания наверху страницы) и поднять также на гелиосе
    Путем обращений из JavaScript к FastCGI серверу требуется показать понимание принципа AJAX

Разработанная HTML-страница должна удовлетворять следующим требованиям:
    Для расположения текстовых и графических элементов необходимо использовать блочную верстку.
    Данные формы должны передаваться на обработку посредством POST-запроса.
    Таблицы стилей должны располагаться в самом веб-документе.
    При работе с CSS должно быть продемонстрировано использование селекторов потомств, селекторов классов, селекторов атрибутов, селекторов псевдоклассов а также такие свойства стилей CSS, как наследование и каскадирование.
    HTML-страница должна иметь "шапку", содержащую ФИО студента, номер группы и новер варианта. При оформлении шапки необходимо явным образом задать шрифт (serif), его цвет и размер в каскадной таблице стилей.
    Отступы элементов ввода должны задаваться в процентах.
    Страница должна содержать сценарий на языке JavaScript, осуществляющий валидацию значений, вводимых пользователем в поля формы. Любые некорректные значения (например, буквы в координатах точки или отрицательный радиус) должны блокироваться.

### Вопросы

#### 1. Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.
ляляля

**HTTP** — это гипертекстовый протокол передачи данных прикладного уровня в сетевой модели OSI. Его представил миру Тим Бернерс-Ли в марте 1991 года. Главная особенность HTTP — представление всех данных в нём в виде простого текста. протокол не сохраняет состояние между запросами. Каждый запрос от клиента для сервера — отдельная транзакция. Передача данных по HTTP осуществляется через открытое TCP/IP-соединение. Серверное программное обеспечение по умолчанию обычно использует TCP-порт 80 для работы веб-сервера, а порт 443 — для HTTPS-соединений. **HTTPS (HTTP _Secure_**) — это надстройка над протоколом HTTP, которая поддерживает шифрование посредством криптографических протоколов SSL и TLS.
- **HEAD** запрашивает ресурс так же, как и метод GET, но без тела ответа. Так можно получить только заголовки, без самого ресурса.
- **POST** добавляет сущность к определённому ресурсу. Часто вызывает изменение состояния или побочные эффекты на сервере. Например, так можно отправить запрос на добавление нового поста в блог.

Методы запроса описывают тип обработки данных, который клиент хочет осуществить. Доступны следующие методы:
- `OPTIONS` — используется для определения возможностей сервера по преобразованию данных.
- `GET` — используется для получения данных от сервера.
- `HEAD` — то же, что и `GET`, но не содержит тело в сообщении ответа.
- `POST` — используется для отправки данных на сервер.
- `PUT` — используется для добавления новых или изменения существующих данных на сервере.
- `PATCH` — то же, что и `PUT`, но используется для обновления части данных.
- `DELETE` — используется для удаления данных на сервере.
- `TRACE` — возвращает запрос от клиента таким образом, что в ответе содержится информация о преобразованиях запроса на промежуточных серверах.
- `CONNECT` — переводит текущее соединение в TCP/IP-туннель. Обычно этот метод используется для установления защищённого SSL-соединения.

Простой пример запроса:
```
GET /path HTTP/1.0
Content-Type: text/html; charset=utf-8
Content-Length: 4
X-Custom-Header: value

test
```
Пример ответа:
```
HTTP/1.1 200 OK
Date: Thu, 29 Jul 2021 19:20:01 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 2
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

OK
```

Заголовки:
1. `Content-Type` — стандартный заголовок. Показывает, в каком формате будут передаваться данные в теле запроса или ответа.
2. `Content-Length` — сообщает длину контента в теле запроса в байтах.
3. `X-Custom-Header` — пользовательские заголовки, начинающиеся с `X-` с произвольными именем. Через них реализуется специфическая логика обработки для конкретного сервера. Если веб-сервер не поддерживает такие заголовки, то он проигнорирует их.
Чаще всего встречаются типы:
- text/html.
- application/json.
- multipart/form-data.


Статусы ответов:
- Информационные ответы
	**100 Continue** — промежуточный ответ. Он указывает, что запрос успешно принят.  Клиент может продолжать присылать запросы или проигнорировать этот ответ, если запрос был завершён.
	**101 Switching Protocol** присылается в ответ на запрос, в котором есть заголовок _Upgrade_. Это означает, что сервер переключился на протокол, который был указан в заголовке. Такая методика используется, например, для переключения на протокол _Websocket_.
	**102 Processing** — запрос получен сервером, но его обработка ещё не завершена.
-  Успешные ответы
	**200 OK** — запрос принят и корректно обработан веб-сервером.
	**201 Created** — запрос корректно обработан и в результате был создан новый ресурс. Обычно он присылается в ответ на POST запрос.
- Редиректы
	**301 Moved Permanently** — запрашиваемый ресурс на постоянной основе переехал на новый адрес. Тогда новый путь к ресурсу указывается сервером в заголовке `Location` ответа. (Клиент может изменить метод последующего запроса с POST на GET.)
	**302 Found** — указывает, что целевой ресурс временно доступен по другому URl. Адрес перенаправления может быть изменен в любое время, а клиент должен продолжать использовать действующий URI для будущих запросов. Тогда временный путь к ресурсу указывается сервером в заголовке `Location` ответа. (Клиент может изменить метод последующего запроса с POST на GET.)
	**307 Temporary Redirect** — имеет то же значение, что и код 302, за исключением того, что клиент не может менять метод последующего запроса.
	**308 Permanent Redirect** — имеет то же значение, что и код 301, за исключением того, что клиент не может менять метод последующего запроса.
-  Клиентские ошибки
	**400 Bad Request** — запрос от клиента к веб-серверу составлен некорректно. Обычно это происходит, если клиент не передаёт необходимые заголовки или параметры.
	**401 Unauthorized** — получение запрашиваемого ресурса доступно только аутентифицированным пользователям.
	**403 Forbidden** — у клиента не хватает прав для получения запрашиваемого ресурса. Например, когда обычный пользователь сайта пытается получить доступ к панели администратора.
	**404 Not Found** — сервер не смог найти запрашиваемый ресурс.
	**405 Method Not Allowed** — сервер знает о существовании HTTP-метода, который был указан в запросе, но не поддерживает его. В таком случае сервер должен вернуть список поддерживаемых методов в заголовке `Allow` ответа.
-  Серверные ошибки
	**500 Internal Server Error** — на сервере произошла непредвиденная ошибка.
	**501 Not Implemented** — метод запроса не поддерживается сервером и не может быть обработан.
	**502 Bad Gateway** — сервер, действуя как шлюз или прокси, получил недопустимый ответ от входящего сервера, к которому он обращался при попытке выполнить запрос.
	**503 Service Unavailable** — сервер не готов обработать запрос (например, из-за технического обслуживания или перегрузки). Обратите внимание, что вместе с этим ответом должна быть отправлена ​​удобная страница с объяснением проблемы. Этот ответ следует использовать для временных условий, а HTTP-заголовок `Retry-After` по возможности должен содержать расчётное время до восстановления службы.
	**504 Gateway Timeout** — этот ответ об ошибке выдается, когда сервер действует как шлюз и не может получить ответ за отведенное время.
	**505 HTTP Version Not Supported** — версия HTTP, используемая в запросе, не поддерживается сервером.

#### 2. Язык разметки HTML. Особенности, основные теги и атрибуты тегов.
#### 3. Структура HTML-страницы. Объектная модель документа (DOM).
DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.
Браузер создаёт DOM при загрузке страницы, складывает его в переменную `document` и сообщает, что DOM создан, с помощью [события](https://doka-guide.vercel.app/js/events/) [`DOMContentLoaded`](https://doka-guide.vercel.app/js/event-domcontentloaded/). С переменной `document` начинается любая работа с HTML-разметкой в JavaScript.

#### 4. HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.
#### 5. Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.
#### 6. LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.
#### 7. Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.
Современный JavaScript используется не только в браузерах. Среда, в которой он запускается, будь то браузер, сервер или что-то ещё, называется _окружением_.
У разных окружений разные возможности и функциональность. В этой статье рассмотрим браузерное окружение и браузерную модель документа.
Окружение предоставляет языку дополнительные возможности и функции. Браузерное окружение, например, даёт возможность работать со страницами сайтов.
Представление этих дополнительных возможностей и функциональности в виде объектов, к которым у языка есть доступ — это объектная модель.
В случае с браузерным окружением — это объектная модель браузера (_Browser Object Model, BOM_). Она предоставляет доступ к [`navigator`](https://doka-guide.vercel.app/js/window-navigator/), [`location`](https://doka-guide.vercel.app/js/window-location/), [`fetch`](https://doka-guide.vercel.app/js/fetch/) и другим объектам.
Объект [`navigator`](https://doka-guide.vercel.app/js/window-navigator/) содержит информацию о браузере: название, версия, платформа, доступные плагины, доступ к буферу обмена и прочее.
Объект `screen` содержит информацию об экране браузера.

Объект [`location`](https://doka-guide.vercel.app/js/window-location/) даёт возможность узнать, на какой странице мы находимся (какой у неё URL) и перейти на другую страницу программно.
- `href` содержит URL целиком, включая в себя полный адрес хоста, страницы и все query-параметры.
- `host` и `hostname` указывают имя хоста. Разница между ними в том, что `host` включает в себя порт. Если бы мы стучались не на `[google.com](http://google.com)`, а на `google.com:8080`, то `host` содержал бы значение `www.google.com:8080`, в то время как `hostname` остался бы тем же.
- `pathname` указывает путь от корня адреса до текущей страницы.
- `search` указывает query-параметры, которые находятся в адресной строке, если они есть.
- `hash` указывает хеш (ID элемента после `#`) страницы. Его ещё называют якорем, потому что при переходе на страницу с хешем браузер найдёт элемент с ID, равным этому хешу, и прокрутит страницу к этому элементу.
Если мы хотим изменить адрес и перейти на другую страницу, мы можем указать новый `location.href`:
`location.href = 'https://yandex.ru'`

[`fetch`](https://doka-guide.vercel.app/js/fetch/) предоставляет возможность работы с сетью, с его помощью можно отправлять запросы на сервер.
```javascript
fetch('http://example.com/movies.json')
.then((response) => {     
return response.json()   
})   
.then((data) => {     
console.log(data)   
})
```

[`history`](https://doka-guide.vercel.app/js/window-history/) даёт доступ к истории браузера, которая ограничена текущей вкладкой. То есть с её помощью можно перейти на страницу назад, только если мы пришли с неё.

Локальные хранилища используются, чтобы хранить какие-то данные в браузере пользователя.
```javascript
function saveToStorage(data) {
  try {
    window.localStorage.setItem('some-key', JSON.stringify(data))
  } catch {
    alert('Failed to save data to local storage.')
  }
}

function loadFromStorage() {
  try {
    return JSON.parse(window.localStorage.getItem('some-key'))
  } catch {
    alert('Failed to load data from local storage.')
  }
}

// Код обработки формы

function nextStep() {
  // При переходе сохраняем всё, что введено:
  saveToStorage(formData)
}
```
Разница между [`localStorage`](https://doka-guide.vercel.app/js/local-storage/) и [`sessionStorage`](https://doka-guide.vercel.app/js/session-storage/) в длительности хранения данных. Данные из `sessionStorage` сотрутся, когда пользователь закроет вкладку с приложением. Данные же из `localStorage` не стираются сами по себе.

##### fetch
С помощью второго аргумента `options` можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Так же в запрос можно добавить заголовки в виде объекта или специального класса `Headers`.
```javascript
const newPost = {
  title: 'foo',
  body: 'bar',
  userId: 1,
}

fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // Здесь так же могут быть GET, PUT, DELETE
  body: JSON.stringify(newPost), // Тело запроса в JSON-формате
  headers: {
    // Добавляем необходимые заголовки
    'Content-type': 'application/json; charset=UTF-8',
  },
})
  .then((response) => response.json())
  .then((data) => {
    console.log(data)
    // {title: "foo", body: "bar", userId: 1, id: 101}
  })
```


#### 8. Версии ECMAScript, новые возможности ES6 и ES7.
#### 9. Синхронная и асинхронная обработка HTTP-запросов. AJAX.
#### 10. Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.
#### 11. Реализация AJAX с помощью SuperAgent.
#### 12. Серверные сценарии. CGI - определение, назначение, ключевые особенности.
#### 13. FastCGI - особенности технологии, преимущества и недостатки относительно CGI.
#### 14. FastCGI сервер на языке Java.